# Использование системы скриптов Mental Engine

## Что было реализовано

Полная система автоматического вызова функций `init` и `update` при рендеринге объектов через Lua скрипты с возможностью управления трансформациями объекта.

## Как это работает

1. **При подключении скрипта**: Скрипт загружается и выполняется один раз для определения функций
2. **При первом рендере**: Автоматически вызывается функция `init()` (если она существует)
3. **При каждом кадре**: 
   - Вызывается функция `update()` для обновления логики
   - Вызываются функции `getRotation()`, `getPosition()`, `getScale()` для получения новых трансформаций
   - Трансформации применяются к объекту

## Пример использования

### 1. Создание скрипта вращения

Создайте файл `my_rotate_script.lua`:

```lua
local rotationY = 0.0

function init()
    print("Объект начинает вращаться!")
    rotationY = 0.0
end

function update()
    rotationY = rotationY + 0.02  -- Увеличиваем вращение
    
    -- Сбрасываем при полном обороте
    if rotationY > 6.28 then  -- 2 * PI
        rotationY = 0.0
        print("Полный оборот завершен!")
    end
end

function getRotation()
    return rotationY  -- Возвращаем текущее вращение
end
```

### 2. Подключение к объекту

```cpp
// Создание объекта
auto triangle = CMentalObject::createTriangle("MyTriangle");

// Подключение шейдера
triangle->connectShader("vertex.glsl", "fragment.glsl");

// Подключение скрипта
triangle->connectScript("path/to/my_rotate_script.lua");

// Треугольник будет автоматически вращаться!
```

## Готовые примеры скриптов

- `simple_rotate.lua` - простое вращение вокруг Y оси
- `rotate_script.lua` - базовый пример с отладочным выводом
- `full_transform_script.lua` - полная анимация (позиция + вращение + масштаб)
- `demo_script.lua` - демонстрационный скрипт с подробными комментариями

## Функции скрипта

### Обязательные функции
- `init()` - инициализация (вызывается один раз)
- `update()` - обновление логики (вызывается каждый кадр)

### Функции трансформации (опциональные)
- `getRotation()` - возвращает вращение по Y в радианах
- `getPosition()` - возвращает позицию (x, y, z)
- `getScale()` - возвращает масштаб (x, y, z)

## Пример комплексной анимации

```lua
local time = 0.0

function init()
    time = 0.0
    print("Комплексная анимация запущена!")
end

function update()
    time = time + 0.016  -- ~60 FPS
end

function getRotation()
    return time * 1.0  -- 1 радиан в секунду
end

function getPosition()
    local x = math.sin(time * 0.5) * 2.0  -- Движение по кругу
    local z = math.cos(time * 0.5) * 2.0
    return x, 0.0, z
end

function getScale()
    local s = 1.0 + 0.3 * math.sin(time * 3.0)  -- Пульсация
    return s, s, s
end
```

## Ключевые особенности

- ✅ Функция `init()` вызывается только один раз при первом рендере
- ✅ Функция `update()` вызывается каждый кадр
- ✅ Функции `getRotation()`, `getPosition()`, `getScale()` позволяют управлять трансформациями
- ✅ Скрипты изолированы - каждый объект имеет свое Lua состояние
- ✅ Ошибки в скриптах не останавливают рендеринг
- ✅ Автоматическое управление жизненным циклом скриптов

## Методы для работы со скриптами

```cpp
// Подключить скрипт
object->connectScript("script.lua");

// Сбросить инициализацию (для повторного вызова init)
object->resetScriptInitialization();
```

## Решение проблемы с вращением

Если треугольник не вращается, убедитесь что:

1. **Скрипт содержит функцию `getRotation()`**:
```lua
function getRotation()
    return rotationY  -- Должна возвращать число в радианах
end
```

2. **Функция возвращает изменяющееся значение**:
```lua
function update()
    rotationY = rotationY + 0.02  -- Увеличиваем каждый кадр
end
```

3. **Скрипт подключен к объекту**:
```cpp
triangle->connectScript("common/Scripts/rotate_script.lua");
```

Теперь треугольник должен вращаться автоматически при рендеринге!